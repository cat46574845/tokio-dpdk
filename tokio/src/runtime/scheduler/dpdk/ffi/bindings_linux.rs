/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
unsafe extern "C" {
    pub fn rte_eal_init(
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn rte_eal_cleanup() -> ::core::ffi::c_int;
}
pub type rte_iova_t = u64;
pub type RTE_MARKER = [*mut ::core::ffi::c_void; 0usize];
pub type RTE_MARKER64 = [u64; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_device {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn rte_socket_id() -> ::core::ffi::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_thresh {
    pub pthresh: u8,
    pub hthresh: u8,
    pub wthresh: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_thresh"][::core::mem::size_of::<rte_eth_thresh>() - 3usize];
    ["Alignment of rte_eth_thresh"][::core::mem::align_of::<rte_eth_thresh>() - 1usize];
    ["Offset of field: rte_eth_thresh::pthresh"]
        [::core::mem::offset_of!(rte_eth_thresh, pthresh) - 0usize];
    ["Offset of field: rte_eth_thresh::hthresh"]
        [::core::mem::offset_of!(rte_eth_thresh, hthresh) - 1usize];
    ["Offset of field: rte_eth_thresh::wthresh"]
        [::core::mem::offset_of!(rte_eth_thresh, wthresh) - 2usize];
};
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_NONE: rte_eth_rx_mq_mode = 0;
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_RSS: rte_eth_rx_mq_mode = 1;
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_DCB: rte_eth_rx_mq_mode = 2;
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_DCB_RSS: rte_eth_rx_mq_mode = 3;
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_VMDQ_ONLY: rte_eth_rx_mq_mode = 4;
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_VMDQ_RSS: rte_eth_rx_mq_mode = 5;
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_VMDQ_DCB: rte_eth_rx_mq_mode = 6;
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_VMDQ_DCB_RSS: rte_eth_rx_mq_mode = 7;
pub type rte_eth_rx_mq_mode = ::core::ffi::c_uint;
pub const rte_eth_tx_mq_mode_RTE_ETH_MQ_TX_NONE: rte_eth_tx_mq_mode = 0;
pub const rte_eth_tx_mq_mode_RTE_ETH_MQ_TX_DCB: rte_eth_tx_mq_mode = 1;
pub const rte_eth_tx_mq_mode_RTE_ETH_MQ_TX_VMDQ_DCB: rte_eth_tx_mq_mode = 2;
pub const rte_eth_tx_mq_mode_RTE_ETH_MQ_TX_VMDQ_ONLY: rte_eth_tx_mq_mode = 3;
pub type rte_eth_tx_mq_mode = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rxmode {
    pub mq_mode: rte_eth_rx_mq_mode,
    pub mtu: u32,
    pub max_lro_pkt_size: u32,
    pub offloads: u64,
    pub reserved_64s: [u64; 2usize],
    pub reserved_ptrs: [*mut ::core::ffi::c_void; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_rxmode"][::core::mem::size_of::<rte_eth_rxmode>() - 56usize];
    ["Alignment of rte_eth_rxmode"][::core::mem::align_of::<rte_eth_rxmode>() - 8usize];
    ["Offset of field: rte_eth_rxmode::mq_mode"]
        [::core::mem::offset_of!(rte_eth_rxmode, mq_mode) - 0usize];
    ["Offset of field: rte_eth_rxmode::mtu"][::core::mem::offset_of!(rte_eth_rxmode, mtu) - 4usize];
    ["Offset of field: rte_eth_rxmode::max_lro_pkt_size"]
        [::core::mem::offset_of!(rte_eth_rxmode, max_lro_pkt_size) - 8usize];
    ["Offset of field: rte_eth_rxmode::offloads"]
        [::core::mem::offset_of!(rte_eth_rxmode, offloads) - 16usize];
    ["Offset of field: rte_eth_rxmode::reserved_64s"]
        [::core::mem::offset_of!(rte_eth_rxmode, reserved_64s) - 24usize];
    ["Offset of field: rte_eth_rxmode::reserved_ptrs"]
        [::core::mem::offset_of!(rte_eth_rxmode, reserved_ptrs) - 40usize];
};
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_DEFAULT: rte_eth_hash_function = 0;
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_TOEPLITZ: rte_eth_hash_function = 1;
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_SIMPLE_XOR: rte_eth_hash_function = 2;
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ: rte_eth_hash_function = 3;
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ_SORT:
    rte_eth_hash_function = 4;
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_MAX: rte_eth_hash_function = 5;
pub type rte_eth_hash_function = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rss_conf {
    pub rss_key: *mut u8,
    pub rss_key_len: u8,
    pub rss_hf: u64,
    pub algorithm: rte_eth_hash_function,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_rss_conf"][::core::mem::size_of::<rte_eth_rss_conf>() - 32usize];
    ["Alignment of rte_eth_rss_conf"][::core::mem::align_of::<rte_eth_rss_conf>() - 8usize];
    ["Offset of field: rte_eth_rss_conf::rss_key"]
        [::core::mem::offset_of!(rte_eth_rss_conf, rss_key) - 0usize];
    ["Offset of field: rte_eth_rss_conf::rss_key_len"]
        [::core::mem::offset_of!(rte_eth_rss_conf, rss_key_len) - 8usize];
    ["Offset of field: rte_eth_rss_conf::rss_hf"]
        [::core::mem::offset_of!(rte_eth_rss_conf, rss_hf) - 16usize];
    ["Offset of field: rte_eth_rss_conf::algorithm"]
        [::core::mem::offset_of!(rte_eth_rss_conf, algorithm) - 24usize];
};
pub const rte_eth_nb_tcs_RTE_ETH_4_TCS: rte_eth_nb_tcs = 4;
pub const rte_eth_nb_tcs_RTE_ETH_8_TCS: rte_eth_nb_tcs = 8;
pub type rte_eth_nb_tcs = ::core::ffi::c_uint;
pub const rte_eth_nb_pools_RTE_ETH_8_POOLS: rte_eth_nb_pools = 8;
pub const rte_eth_nb_pools_RTE_ETH_16_POOLS: rte_eth_nb_pools = 16;
pub const rte_eth_nb_pools_RTE_ETH_32_POOLS: rte_eth_nb_pools = 32;
pub const rte_eth_nb_pools_RTE_ETH_64_POOLS: rte_eth_nb_pools = 64;
pub type rte_eth_nb_pools = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_rx_conf {
    pub nb_tcs: rte_eth_nb_tcs,
    pub dcb_tc: [u8; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_dcb_rx_conf"][::core::mem::size_of::<rte_eth_dcb_rx_conf>() - 12usize];
    ["Alignment of rte_eth_dcb_rx_conf"][::core::mem::align_of::<rte_eth_dcb_rx_conf>() - 4usize];
    ["Offset of field: rte_eth_dcb_rx_conf::nb_tcs"]
        [::core::mem::offset_of!(rte_eth_dcb_rx_conf, nb_tcs) - 0usize];
    ["Offset of field: rte_eth_dcb_rx_conf::dcb_tc"]
        [::core::mem::offset_of!(rte_eth_dcb_rx_conf, dcb_tc) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_dcb_tx_conf {
    pub nb_queue_pools: rte_eth_nb_pools,
    pub dcb_tc: [u8; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_vmdq_dcb_tx_conf"]
        [::core::mem::size_of::<rte_eth_vmdq_dcb_tx_conf>() - 12usize];
    ["Alignment of rte_eth_vmdq_dcb_tx_conf"]
        [::core::mem::align_of::<rte_eth_vmdq_dcb_tx_conf>() - 4usize];
    ["Offset of field: rte_eth_vmdq_dcb_tx_conf::nb_queue_pools"]
        [::core::mem::offset_of!(rte_eth_vmdq_dcb_tx_conf, nb_queue_pools) - 0usize];
    ["Offset of field: rte_eth_vmdq_dcb_tx_conf::dcb_tc"]
        [::core::mem::offset_of!(rte_eth_vmdq_dcb_tx_conf, dcb_tc) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_tx_conf {
    pub nb_tcs: rte_eth_nb_tcs,
    pub dcb_tc: [u8; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_dcb_tx_conf"][::core::mem::size_of::<rte_eth_dcb_tx_conf>() - 12usize];
    ["Alignment of rte_eth_dcb_tx_conf"][::core::mem::align_of::<rte_eth_dcb_tx_conf>() - 4usize];
    ["Offset of field: rte_eth_dcb_tx_conf::nb_tcs"]
        [::core::mem::offset_of!(rte_eth_dcb_tx_conf, nb_tcs) - 0usize];
    ["Offset of field: rte_eth_dcb_tx_conf::dcb_tc"]
        [::core::mem::offset_of!(rte_eth_dcb_tx_conf, dcb_tc) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_tx_conf {
    pub nb_queue_pools: rte_eth_nb_pools,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_vmdq_tx_conf"][::core::mem::size_of::<rte_eth_vmdq_tx_conf>() - 4usize];
    ["Alignment of rte_eth_vmdq_tx_conf"][::core::mem::align_of::<rte_eth_vmdq_tx_conf>() - 4usize];
    ["Offset of field: rte_eth_vmdq_tx_conf::nb_queue_pools"]
        [::core::mem::offset_of!(rte_eth_vmdq_tx_conf, nb_queue_pools) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_dcb_conf {
    pub nb_queue_pools: rte_eth_nb_pools,
    pub enable_default_pool: u8,
    pub default_pool: u8,
    pub nb_pool_maps: u8,
    pub pool_map: [rte_eth_vmdq_dcb_conf__bindgen_ty_1; 64usize],
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_dcb_conf__bindgen_ty_1 {
    pub vlan_id: u16,
    pub pools: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_vmdq_dcb_conf__bindgen_ty_1"]
        [::core::mem::size_of::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>() - 16usize];
    ["Alignment of rte_eth_vmdq_dcb_conf__bindgen_ty_1"]
        [::core::mem::align_of::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_eth_vmdq_dcb_conf__bindgen_ty_1::vlan_id"]
        [::core::mem::offset_of!(rte_eth_vmdq_dcb_conf__bindgen_ty_1, vlan_id) - 0usize];
    ["Offset of field: rte_eth_vmdq_dcb_conf__bindgen_ty_1::pools"]
        [::core::mem::offset_of!(rte_eth_vmdq_dcb_conf__bindgen_ty_1, pools) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_vmdq_dcb_conf"][::core::mem::size_of::<rte_eth_vmdq_dcb_conf>() - 1040usize];
    ["Alignment of rte_eth_vmdq_dcb_conf"]
        [::core::mem::align_of::<rte_eth_vmdq_dcb_conf>() - 8usize];
    ["Offset of field: rte_eth_vmdq_dcb_conf::nb_queue_pools"]
        [::core::mem::offset_of!(rte_eth_vmdq_dcb_conf, nb_queue_pools) - 0usize];
    ["Offset of field: rte_eth_vmdq_dcb_conf::enable_default_pool"]
        [::core::mem::offset_of!(rte_eth_vmdq_dcb_conf, enable_default_pool) - 4usize];
    ["Offset of field: rte_eth_vmdq_dcb_conf::default_pool"]
        [::core::mem::offset_of!(rte_eth_vmdq_dcb_conf, default_pool) - 5usize];
    ["Offset of field: rte_eth_vmdq_dcb_conf::nb_pool_maps"]
        [::core::mem::offset_of!(rte_eth_vmdq_dcb_conf, nb_pool_maps) - 6usize];
    ["Offset of field: rte_eth_vmdq_dcb_conf::pool_map"]
        [::core::mem::offset_of!(rte_eth_vmdq_dcb_conf, pool_map) - 8usize];
    ["Offset of field: rte_eth_vmdq_dcb_conf::dcb_tc"]
        [::core::mem::offset_of!(rte_eth_vmdq_dcb_conf, dcb_tc) - 1032usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_rx_conf {
    pub nb_queue_pools: rte_eth_nb_pools,
    pub enable_default_pool: u8,
    pub default_pool: u8,
    pub enable_loop_back: u8,
    pub nb_pool_maps: u8,
    pub rx_mode: u32,
    pub pool_map: [rte_eth_vmdq_rx_conf__bindgen_ty_1; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_rx_conf__bindgen_ty_1 {
    pub vlan_id: u16,
    pub pools: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_vmdq_rx_conf__bindgen_ty_1"]
        [::core::mem::size_of::<rte_eth_vmdq_rx_conf__bindgen_ty_1>() - 16usize];
    ["Alignment of rte_eth_vmdq_rx_conf__bindgen_ty_1"]
        [::core::mem::align_of::<rte_eth_vmdq_rx_conf__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_eth_vmdq_rx_conf__bindgen_ty_1::vlan_id"]
        [::core::mem::offset_of!(rte_eth_vmdq_rx_conf__bindgen_ty_1, vlan_id) - 0usize];
    ["Offset of field: rte_eth_vmdq_rx_conf__bindgen_ty_1::pools"]
        [::core::mem::offset_of!(rte_eth_vmdq_rx_conf__bindgen_ty_1, pools) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_vmdq_rx_conf"][::core::mem::size_of::<rte_eth_vmdq_rx_conf>() - 1040usize];
    ["Alignment of rte_eth_vmdq_rx_conf"][::core::mem::align_of::<rte_eth_vmdq_rx_conf>() - 8usize];
    ["Offset of field: rte_eth_vmdq_rx_conf::nb_queue_pools"]
        [::core::mem::offset_of!(rte_eth_vmdq_rx_conf, nb_queue_pools) - 0usize];
    ["Offset of field: rte_eth_vmdq_rx_conf::enable_default_pool"]
        [::core::mem::offset_of!(rte_eth_vmdq_rx_conf, enable_default_pool) - 4usize];
    ["Offset of field: rte_eth_vmdq_rx_conf::default_pool"]
        [::core::mem::offset_of!(rte_eth_vmdq_rx_conf, default_pool) - 5usize];
    ["Offset of field: rte_eth_vmdq_rx_conf::enable_loop_back"]
        [::core::mem::offset_of!(rte_eth_vmdq_rx_conf, enable_loop_back) - 6usize];
    ["Offset of field: rte_eth_vmdq_rx_conf::nb_pool_maps"]
        [::core::mem::offset_of!(rte_eth_vmdq_rx_conf, nb_pool_maps) - 7usize];
    ["Offset of field: rte_eth_vmdq_rx_conf::rx_mode"]
        [::core::mem::offset_of!(rte_eth_vmdq_rx_conf, rx_mode) - 8usize];
    ["Offset of field: rte_eth_vmdq_rx_conf::pool_map"]
        [::core::mem::offset_of!(rte_eth_vmdq_rx_conf, pool_map) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_txmode {
    pub mq_mode: rte_eth_tx_mq_mode,
    pub offloads: u64,
    pub pvid: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved_64s: [u64; 2usize],
    pub reserved_ptrs: [*mut ::core::ffi::c_void; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_txmode"][::core::mem::size_of::<rte_eth_txmode>() - 56usize];
    ["Alignment of rte_eth_txmode"][::core::mem::align_of::<rte_eth_txmode>() - 8usize];
    ["Offset of field: rte_eth_txmode::mq_mode"]
        [::core::mem::offset_of!(rte_eth_txmode, mq_mode) - 0usize];
    ["Offset of field: rte_eth_txmode::offloads"]
        [::core::mem::offset_of!(rte_eth_txmode, offloads) - 8usize];
    ["Offset of field: rte_eth_txmode::pvid"]
        [::core::mem::offset_of!(rte_eth_txmode, pvid) - 16usize];
    ["Offset of field: rte_eth_txmode::reserved_64s"]
        [::core::mem::offset_of!(rte_eth_txmode, reserved_64s) - 24usize];
    ["Offset of field: rte_eth_txmode::reserved_ptrs"]
        [::core::mem::offset_of!(rte_eth_txmode, reserved_ptrs) - 40usize];
};
impl rte_eth_txmode {
    #[inline]
    pub fn hw_vlan_reject_tagged(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_tagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_vlan_reject_tagged_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hw_vlan_reject_tagged_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_vlan_reject_untagged(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_untagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_vlan_reject_untagged_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hw_vlan_reject_untagged_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_vlan_insert_pvid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_insert_pvid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_vlan_insert_pvid_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hw_vlan_insert_pvid_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hw_vlan_reject_tagged: u8,
        hw_vlan_reject_untagged: u8,
        hw_vlan_insert_pvid: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hw_vlan_reject_tagged: u8 =
                unsafe { ::core::mem::transmute(hw_vlan_reject_tagged) };
            hw_vlan_reject_tagged as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hw_vlan_reject_untagged: u8 =
                unsafe { ::core::mem::transmute(hw_vlan_reject_untagged) };
            hw_vlan_reject_untagged as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hw_vlan_insert_pvid: u8 = unsafe { ::core::mem::transmute(hw_vlan_insert_pvid) };
            hw_vlan_insert_pvid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rxseg_split {
    pub mp: *mut rte_mempool,
    pub length: u16,
    pub offset: u16,
    pub proto_hdr: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_rxseg_split"][::core::mem::size_of::<rte_eth_rxseg_split>() - 16usize];
    ["Alignment of rte_eth_rxseg_split"][::core::mem::align_of::<rte_eth_rxseg_split>() - 8usize];
    ["Offset of field: rte_eth_rxseg_split::mp"]
        [::core::mem::offset_of!(rte_eth_rxseg_split, mp) - 0usize];
    ["Offset of field: rte_eth_rxseg_split::length"]
        [::core::mem::offset_of!(rte_eth_rxseg_split, length) - 8usize];
    ["Offset of field: rte_eth_rxseg_split::offset"]
        [::core::mem::offset_of!(rte_eth_rxseg_split, offset) - 10usize];
    ["Offset of field: rte_eth_rxseg_split::proto_hdr"]
        [::core::mem::offset_of!(rte_eth_rxseg_split, proto_hdr) - 12usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_rxseg {
    pub split: rte_eth_rxseg_split,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_rxseg"][::core::mem::size_of::<rte_eth_rxseg>() - 16usize];
    ["Alignment of rte_eth_rxseg"][::core::mem::align_of::<rte_eth_rxseg>() - 8usize];
    ["Offset of field: rte_eth_rxseg::split"]
        [::core::mem::offset_of!(rte_eth_rxseg, split) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rxconf {
    pub rx_thresh: rte_eth_thresh,
    pub rx_free_thresh: u16,
    pub rx_drop_en: u8,
    pub rx_deferred_start: u8,
    pub rx_nseg: u16,
    pub share_group: u16,
    pub share_qid: u16,
    pub offloads: u64,
    pub rx_seg: *mut rte_eth_rxseg,
    pub rx_mempools: *mut *mut rte_mempool,
    pub rx_nmempool: u16,
    pub reserved_64s: [u64; 2usize],
    pub reserved_ptrs: [*mut ::core::ffi::c_void; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_rxconf"][::core::mem::size_of::<rte_eth_rxconf>() - 80usize];
    ["Alignment of rte_eth_rxconf"][::core::mem::align_of::<rte_eth_rxconf>() - 8usize];
    ["Offset of field: rte_eth_rxconf::rx_thresh"]
        [::core::mem::offset_of!(rte_eth_rxconf, rx_thresh) - 0usize];
    ["Offset of field: rte_eth_rxconf::rx_free_thresh"]
        [::core::mem::offset_of!(rte_eth_rxconf, rx_free_thresh) - 4usize];
    ["Offset of field: rte_eth_rxconf::rx_drop_en"]
        [::core::mem::offset_of!(rte_eth_rxconf, rx_drop_en) - 6usize];
    ["Offset of field: rte_eth_rxconf::rx_deferred_start"]
        [::core::mem::offset_of!(rte_eth_rxconf, rx_deferred_start) - 7usize];
    ["Offset of field: rte_eth_rxconf::rx_nseg"]
        [::core::mem::offset_of!(rte_eth_rxconf, rx_nseg) - 8usize];
    ["Offset of field: rte_eth_rxconf::share_group"]
        [::core::mem::offset_of!(rte_eth_rxconf, share_group) - 10usize];
    ["Offset of field: rte_eth_rxconf::share_qid"]
        [::core::mem::offset_of!(rte_eth_rxconf, share_qid) - 12usize];
    ["Offset of field: rte_eth_rxconf::offloads"]
        [::core::mem::offset_of!(rte_eth_rxconf, offloads) - 16usize];
    ["Offset of field: rte_eth_rxconf::rx_seg"]
        [::core::mem::offset_of!(rte_eth_rxconf, rx_seg) - 24usize];
    ["Offset of field: rte_eth_rxconf::rx_mempools"]
        [::core::mem::offset_of!(rte_eth_rxconf, rx_mempools) - 32usize];
    ["Offset of field: rte_eth_rxconf::rx_nmempool"]
        [::core::mem::offset_of!(rte_eth_rxconf, rx_nmempool) - 40usize];
    ["Offset of field: rte_eth_rxconf::reserved_64s"]
        [::core::mem::offset_of!(rte_eth_rxconf, reserved_64s) - 48usize];
    ["Offset of field: rte_eth_rxconf::reserved_ptrs"]
        [::core::mem::offset_of!(rte_eth_rxconf, reserved_ptrs) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_txconf {
    pub tx_thresh: rte_eth_thresh,
    pub tx_rs_thresh: u16,
    pub tx_free_thresh: u16,
    pub tx_deferred_start: u8,
    pub offloads: u64,
    pub reserved_64s: [u64; 2usize],
    pub reserved_ptrs: [*mut ::core::ffi::c_void; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_txconf"][::core::mem::size_of::<rte_eth_txconf>() - 56usize];
    ["Alignment of rte_eth_txconf"][::core::mem::align_of::<rte_eth_txconf>() - 8usize];
    ["Offset of field: rte_eth_txconf::tx_thresh"]
        [::core::mem::offset_of!(rte_eth_txconf, tx_thresh) - 0usize];
    ["Offset of field: rte_eth_txconf::tx_rs_thresh"]
        [::core::mem::offset_of!(rte_eth_txconf, tx_rs_thresh) - 4usize];
    ["Offset of field: rte_eth_txconf::tx_free_thresh"]
        [::core::mem::offset_of!(rte_eth_txconf, tx_free_thresh) - 6usize];
    ["Offset of field: rte_eth_txconf::tx_deferred_start"]
        [::core::mem::offset_of!(rte_eth_txconf, tx_deferred_start) - 8usize];
    ["Offset of field: rte_eth_txconf::offloads"]
        [::core::mem::offset_of!(rte_eth_txconf, offloads) - 16usize];
    ["Offset of field: rte_eth_txconf::reserved_64s"]
        [::core::mem::offset_of!(rte_eth_txconf, reserved_64s) - 24usize];
    ["Offset of field: rte_eth_txconf::reserved_ptrs"]
        [::core::mem::offset_of!(rte_eth_txconf, reserved_ptrs) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_desc_lim {
    pub nb_max: u16,
    pub nb_min: u16,
    pub nb_align: u16,
    pub nb_seg_max: u16,
    pub nb_mtu_seg_max: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_desc_lim"][::core::mem::size_of::<rte_eth_desc_lim>() - 10usize];
    ["Alignment of rte_eth_desc_lim"][::core::mem::align_of::<rte_eth_desc_lim>() - 2usize];
    ["Offset of field: rte_eth_desc_lim::nb_max"]
        [::core::mem::offset_of!(rte_eth_desc_lim, nb_max) - 0usize];
    ["Offset of field: rte_eth_desc_lim::nb_min"]
        [::core::mem::offset_of!(rte_eth_desc_lim, nb_min) - 2usize];
    ["Offset of field: rte_eth_desc_lim::nb_align"]
        [::core::mem::offset_of!(rte_eth_desc_lim, nb_align) - 4usize];
    ["Offset of field: rte_eth_desc_lim::nb_seg_max"]
        [::core::mem::offset_of!(rte_eth_desc_lim, nb_seg_max) - 6usize];
    ["Offset of field: rte_eth_desc_lim::nb_mtu_seg_max"]
        [::core::mem::offset_of!(rte_eth_desc_lim, nb_mtu_seg_max) - 8usize];
};
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memzone {
    pub name: [::core::ffi::c_char; 32usize],
    pub iova: rte_iova_t,
    pub __bindgen_anon_1: rte_memzone__bindgen_ty_1,
    pub len: usize,
    pub hugepage_sz: u64,
    pub socket_id: i32,
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memzone__bindgen_ty_1 {
    pub addr: *mut ::core::ffi::c_void,
    pub addr_64: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_memzone__bindgen_ty_1"]
        [::core::mem::size_of::<rte_memzone__bindgen_ty_1>() - 8usize];
    ["Alignment of rte_memzone__bindgen_ty_1"]
        [::core::mem::align_of::<rte_memzone__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_memzone__bindgen_ty_1::addr"]
        [::core::mem::offset_of!(rte_memzone__bindgen_ty_1, addr) - 0usize];
    ["Offset of field: rte_memzone__bindgen_ty_1::addr_64"]
        [::core::mem::offset_of!(rte_memzone__bindgen_ty_1, addr_64) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_memzone"][::core::mem::size_of::<rte_memzone>() - 72usize];
    ["Alignment of rte_memzone"][::core::mem::align_of::<rte_memzone>() - 1usize];
    ["Offset of field: rte_memzone::name"][::core::mem::offset_of!(rte_memzone, name) - 0usize];
    ["Offset of field: rte_memzone::iova"][::core::mem::offset_of!(rte_memzone, iova) - 32usize];
    ["Offset of field: rte_memzone::len"][::core::mem::offset_of!(rte_memzone, len) - 48usize];
    ["Offset of field: rte_memzone::hugepage_sz"]
        [::core::mem::offset_of!(rte_memzone, hugepage_sz) - 56usize];
    ["Offset of field: rte_memzone::socket_id"]
        [::core::mem::offset_of!(rte_memzone, socket_id) - 64usize];
    ["Offset of field: rte_memzone::flags"][::core::mem::offset_of!(rte_memzone, flags) - 68usize];
};
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_cache {
    pub size: u32,
    pub flushthresh: u32,
    pub len: u32,
    pub __bindgen_padding_0: [u64; 6usize],
    pub objs: [*mut ::core::ffi::c_void; 1024usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool_cache"][::core::mem::size_of::<rte_mempool_cache>() - 8256usize];
    ["Alignment of rte_mempool_cache"][::core::mem::align_of::<rte_mempool_cache>() - 64usize];
    ["Offset of field: rte_mempool_cache::size"]
        [::core::mem::offset_of!(rte_mempool_cache, size) - 0usize];
    ["Offset of field: rte_mempool_cache::flushthresh"]
        [::core::mem::offset_of!(rte_mempool_cache, flushthresh) - 4usize];
    ["Offset of field: rte_mempool_cache::len"]
        [::core::mem::offset_of!(rte_mempool_cache, len) - 8usize];
    ["Offset of field: rte_mempool_cache::objs"]
        [::core::mem::offset_of!(rte_mempool_cache, objs) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objhdr {
    pub next: rte_mempool_objhdr__bindgen_ty_1,
    pub mp: *mut rte_mempool,
    pub iova: rte_iova_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_objhdr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool_objhdr__bindgen_ty_1"]
        [::core::mem::size_of::<rte_mempool_objhdr__bindgen_ty_1>() - 8usize];
    ["Alignment of rte_mempool_objhdr__bindgen_ty_1"]
        [::core::mem::align_of::<rte_mempool_objhdr__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_mempool_objhdr__bindgen_ty_1::stqe_next"]
        [::core::mem::offset_of!(rte_mempool_objhdr__bindgen_ty_1, stqe_next) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool_objhdr"][::core::mem::size_of::<rte_mempool_objhdr>() - 24usize];
    ["Alignment of rte_mempool_objhdr"][::core::mem::align_of::<rte_mempool_objhdr>() - 8usize];
    ["Offset of field: rte_mempool_objhdr::next"]
        [::core::mem::offset_of!(rte_mempool_objhdr, next) - 0usize];
    ["Offset of field: rte_mempool_objhdr::mp"]
        [::core::mem::offset_of!(rte_mempool_objhdr, mp) - 8usize];
    ["Offset of field: rte_mempool_objhdr::iova"]
        [::core::mem::offset_of!(rte_mempool_objhdr, iova) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objhdr_list {
    pub stqh_first: *mut rte_mempool_objhdr,
    pub stqh_last: *mut *mut rte_mempool_objhdr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool_objhdr_list"]
        [::core::mem::size_of::<rte_mempool_objhdr_list>() - 16usize];
    ["Alignment of rte_mempool_objhdr_list"]
        [::core::mem::align_of::<rte_mempool_objhdr_list>() - 8usize];
    ["Offset of field: rte_mempool_objhdr_list::stqh_first"]
        [::core::mem::offset_of!(rte_mempool_objhdr_list, stqh_first) - 0usize];
    ["Offset of field: rte_mempool_objhdr_list::stqh_last"]
        [::core::mem::offset_of!(rte_mempool_objhdr_list, stqh_last) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_memhdr_list {
    pub stqh_first: *mut rte_mempool_memhdr,
    pub stqh_last: *mut *mut rte_mempool_memhdr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool_memhdr_list"]
        [::core::mem::size_of::<rte_mempool_memhdr_list>() - 16usize];
    ["Alignment of rte_mempool_memhdr_list"]
        [::core::mem::align_of::<rte_mempool_memhdr_list>() - 8usize];
    ["Offset of field: rte_mempool_memhdr_list::stqh_first"]
        [::core::mem::offset_of!(rte_mempool_memhdr_list, stqh_first) - 0usize];
    ["Offset of field: rte_mempool_memhdr_list::stqh_last"]
        [::core::mem::offset_of!(rte_mempool_memhdr_list, stqh_last) - 8usize];
};
pub type rte_mempool_memchunk_free_cb_t = ::core::option::Option<
    unsafe extern "C" fn(memhdr: *mut rte_mempool_memhdr, opaque: *mut ::core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_memhdr {
    pub next: rte_mempool_memhdr__bindgen_ty_1,
    pub mp: *mut rte_mempool,
    pub addr: *mut ::core::ffi::c_void,
    pub iova: rte_iova_t,
    pub len: usize,
    pub free_cb: rte_mempool_memchunk_free_cb_t,
    pub opaque: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_memhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_memhdr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool_memhdr__bindgen_ty_1"]
        [::core::mem::size_of::<rte_mempool_memhdr__bindgen_ty_1>() - 8usize];
    ["Alignment of rte_mempool_memhdr__bindgen_ty_1"]
        [::core::mem::align_of::<rte_mempool_memhdr__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_mempool_memhdr__bindgen_ty_1::stqe_next"]
        [::core::mem::offset_of!(rte_mempool_memhdr__bindgen_ty_1, stqe_next) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool_memhdr"][::core::mem::size_of::<rte_mempool_memhdr>() - 56usize];
    ["Alignment of rte_mempool_memhdr"][::core::mem::align_of::<rte_mempool_memhdr>() - 8usize];
    ["Offset of field: rte_mempool_memhdr::next"]
        [::core::mem::offset_of!(rte_mempool_memhdr, next) - 0usize];
    ["Offset of field: rte_mempool_memhdr::mp"]
        [::core::mem::offset_of!(rte_mempool_memhdr, mp) - 8usize];
    ["Offset of field: rte_mempool_memhdr::addr"]
        [::core::mem::offset_of!(rte_mempool_memhdr, addr) - 16usize];
    ["Offset of field: rte_mempool_memhdr::iova"]
        [::core::mem::offset_of!(rte_mempool_memhdr, iova) - 24usize];
    ["Offset of field: rte_mempool_memhdr::len"]
        [::core::mem::offset_of!(rte_mempool_memhdr, len) - 32usize];
    ["Offset of field: rte_mempool_memhdr::free_cb"]
        [::core::mem::offset_of!(rte_mempool_memhdr, free_cb) - 40usize];
    ["Offset of field: rte_mempool_memhdr::opaque"]
        [::core::mem::offset_of!(rte_mempool_memhdr, opaque) - 48usize];
};
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool {
    pub name: [::core::ffi::c_char; 26usize],
    pub __bindgen_anon_1: rte_mempool__bindgen_ty_1,
    pub pool_config: *mut ::core::ffi::c_void,
    pub mz: *const rte_memzone,
    pub flags: ::core::ffi::c_uint,
    pub socket_id: ::core::ffi::c_int,
    pub size: u32,
    pub cache_size: u32,
    pub elt_size: u32,
    pub header_size: u32,
    pub trailer_size: u32,
    pub private_data_size: ::core::ffi::c_uint,
    pub ops_index: i32,
    pub local_cache: *mut rte_mempool_cache,
    pub populated_size: u32,
    pub elt_list: rte_mempool_objhdr_list,
    pub nb_mem_chunks: u32,
    pub mem_list: rte_mempool_memhdr_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool__bindgen_ty_1 {
    pub pool_data: *mut ::core::ffi::c_void,
    pub pool_id: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool__bindgen_ty_1"]
        [::core::mem::size_of::<rte_mempool__bindgen_ty_1>() - 8usize];
    ["Alignment of rte_mempool__bindgen_ty_1"]
        [::core::mem::align_of::<rte_mempool__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_mempool__bindgen_ty_1::pool_data"]
        [::core::mem::offset_of!(rte_mempool__bindgen_ty_1, pool_data) - 0usize];
    ["Offset of field: rte_mempool__bindgen_ty_1::pool_id"]
        [::core::mem::offset_of!(rte_mempool__bindgen_ty_1, pool_id) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool"][::core::mem::size_of::<rte_mempool>() - 192usize];
    ["Alignment of rte_mempool"][::core::mem::align_of::<rte_mempool>() - 64usize];
    ["Offset of field: rte_mempool::name"][::core::mem::offset_of!(rte_mempool, name) - 0usize];
    ["Offset of field: rte_mempool::pool_config"]
        [::core::mem::offset_of!(rte_mempool, pool_config) - 40usize];
    ["Offset of field: rte_mempool::mz"][::core::mem::offset_of!(rte_mempool, mz) - 48usize];
    ["Offset of field: rte_mempool::flags"][::core::mem::offset_of!(rte_mempool, flags) - 56usize];
    ["Offset of field: rte_mempool::socket_id"]
        [::core::mem::offset_of!(rte_mempool, socket_id) - 60usize];
    ["Offset of field: rte_mempool::size"][::core::mem::offset_of!(rte_mempool, size) - 64usize];
    ["Offset of field: rte_mempool::cache_size"]
        [::core::mem::offset_of!(rte_mempool, cache_size) - 68usize];
    ["Offset of field: rte_mempool::elt_size"]
        [::core::mem::offset_of!(rte_mempool, elt_size) - 72usize];
    ["Offset of field: rte_mempool::header_size"]
        [::core::mem::offset_of!(rte_mempool, header_size) - 76usize];
    ["Offset of field: rte_mempool::trailer_size"]
        [::core::mem::offset_of!(rte_mempool, trailer_size) - 80usize];
    ["Offset of field: rte_mempool::private_data_size"]
        [::core::mem::offset_of!(rte_mempool, private_data_size) - 84usize];
    ["Offset of field: rte_mempool::ops_index"]
        [::core::mem::offset_of!(rte_mempool, ops_index) - 88usize];
    ["Offset of field: rte_mempool::local_cache"]
        [::core::mem::offset_of!(rte_mempool, local_cache) - 96usize];
    ["Offset of field: rte_mempool::populated_size"]
        [::core::mem::offset_of!(rte_mempool, populated_size) - 104usize];
    ["Offset of field: rte_mempool::elt_list"]
        [::core::mem::offset_of!(rte_mempool, elt_list) - 112usize];
    ["Offset of field: rte_mempool::nb_mem_chunks"]
        [::core::mem::offset_of!(rte_mempool, nb_mem_chunks) - 128usize];
    ["Offset of field: rte_mempool::mem_list"]
        [::core::mem::offset_of!(rte_mempool, mem_list) - 136usize];
};
unsafe extern "C" {
    pub fn rte_mempool_free(mp: *mut rte_mempool);
}
pub type rte_be16_t = u16;
pub type rte_be32_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf_sched {
    pub queue_id: u32,
    pub traffic_class: u8,
    pub color: u8,
    pub reserved: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf_sched"][::core::mem::size_of::<rte_mbuf_sched>() - 8usize];
    ["Alignment of rte_mbuf_sched"][::core::mem::align_of::<rte_mbuf_sched>() - 4usize];
    ["Offset of field: rte_mbuf_sched::queue_id"]
        [::core::mem::offset_of!(rte_mbuf_sched, queue_id) - 0usize];
    ["Offset of field: rte_mbuf_sched::traffic_class"]
        [::core::mem::offset_of!(rte_mbuf_sched, traffic_class) - 4usize];
    ["Offset of field: rte_mbuf_sched::color"]
        [::core::mem::offset_of!(rte_mbuf_sched, color) - 5usize];
    ["Offset of field: rte_mbuf_sched::reserved"]
        [::core::mem::offset_of!(rte_mbuf_sched, reserved) - 6usize];
};
#[repr(C)]
#[repr(align(64))]
pub struct rte_mbuf {
    pub cacheline0: RTE_MARKER,
    pub buf_addr: *mut ::core::ffi::c_void,
    pub buf_iova: rte_iova_t,
    pub rearm_data: RTE_MARKER64,
    pub data_off: u16,
    pub refcnt: u16,
    pub nb_segs: u16,
    pub port: u16,
    pub ol_flags: u64,
    pub rx_descriptor_fields1: RTE_MARKER,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1,
    pub pkt_len: u32,
    pub data_len: u16,
    pub vlan_tci: u16,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2,
    pub vlan_tci_outer: u16,
    pub buf_len: u16,
    pub pool: *mut rte_mempool,
    pub cacheline1: RTE_MARKER,
    pub next: *mut rte_mbuf,
    pub __bindgen_anon_3: rte_mbuf__bindgen_ty_3,
    pub shinfo: *mut rte_mbuf_ext_shared_info,
    pub priv_size: u16,
    pub timesync: u16,
    pub dynfield1: [u32; 9usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_1 {
    pub packet_type: u32,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub inner_esp_next_proto: u8,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
        ) - 1usize];
    ["Alignment of rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
        ) - 1usize];
};
impl rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn inner_l2_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_l2_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_l2_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn inner_l3_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_l3_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_l3_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inner_l2_type: u8,
        inner_l3_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l2_type: u8 = unsafe { ::core::mem::transmute(inner_l2_type) };
            inner_l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let inner_l3_type: u8 = unsafe { ::core::mem::transmute(inner_l3_type) };
            inner_l3_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>() - 1usize];
    ["Alignment of rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>() - 1usize];
    ["Offset of field: rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1::inner_esp_next_proto"][::core::mem::offset_of!(
        rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        inner_esp_next_proto
    )
        - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<rte_mbuf__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Alignment of rte_mbuf__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<rte_mbuf__bindgen_ty_1__bindgen_ty_1>() - 1usize];
};
impl rte_mbuf__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn l2_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l2_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_l2_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l3_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_l3_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l4_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l4_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l4_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_l4_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tun_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tun_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tun_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_tun_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_type: u8,
        l3_type: u8,
        l4_type: u8,
        tun_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let l2_type: u8 = unsafe { ::core::mem::transmute(l2_type) };
            l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let l3_type: u8 = unsafe { ::core::mem::transmute(l3_type) };
            l3_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let l4_type: u8 = unsafe { ::core::mem::transmute(l4_type) };
            l4_type as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let tun_type: u8 = unsafe { ::core::mem::transmute(tun_type) };
            tun_type as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn inner_l4_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l4_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_l4_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_l4_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(inner_l4_type: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l4_type: u8 = unsafe { ::core::mem::transmute(inner_l4_type) };
            inner_l4_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_1"][::core::mem::size_of::<rte_mbuf__bindgen_ty_1>() - 4usize];
    ["Alignment of rte_mbuf__bindgen_ty_1"]
        [::core::mem::align_of::<rte_mbuf__bindgen_ty_1>() - 4usize];
    ["Offset of field: rte_mbuf__bindgen_ty_1::packet_type"]
        [::core::mem::offset_of!(rte_mbuf__bindgen_ty_1, packet_type) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2 {
    pub hash: rte_mbuf__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    pub rss: u32,
    pub fdir: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub sched: rte_mbuf_sched,
    pub txadapter: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    pub usr: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub hi: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1:
        rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub lo: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u16,
    pub id: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<
            rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >() - 4usize];
    ["Alignment of rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"] [:: core :: mem :: align_of :: < rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > () - 2usize] ;
    ["Offset of field: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1::hash"] [:: core :: mem :: offset_of ! (rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , hash) - 0usize] ;
    ["Offset of field: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1::id"] [:: core :: mem :: offset_of ! (rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , id) - 2usize] ;
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
        ) - 4usize];
    ["Alignment of rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
        ) - 4usize];
    ["Offset of field: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1::lo"][::core::mem::offset_of!(
        rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        lo
    )
        - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1::hi"]
        [::core::mem::offset_of!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1, hi) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub reserved1: u32,
    pub reserved2: u16,
    pub txq: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2"]
        [::core::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>() - 8usize];
    ["Alignment of rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2"]
        [::core::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>() - 4usize];
    ["Offset of field: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2::reserved1"][::core::mem::offset_of!(
        rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
        reserved1
    ) - 0usize];
    ["Offset of field: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2::reserved2"][::core::mem::offset_of!(
        rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
        reserved2
    ) - 4usize];
    ["Offset of field: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2::txq"]
        [::core::mem::offset_of!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2, txq) - 6usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_2__bindgen_ty_1"]
        [::core::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1>() - 8usize];
    ["Alignment of rte_mbuf__bindgen_ty_2__bindgen_ty_1"]
        [::core::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1>() - 4usize];
    ["Offset of field: rte_mbuf__bindgen_ty_2__bindgen_ty_1::rss"]
        [::core::mem::offset_of!(rte_mbuf__bindgen_ty_2__bindgen_ty_1, rss) - 0usize];
    ["Offset of field: rte_mbuf__bindgen_ty_2__bindgen_ty_1::fdir"]
        [::core::mem::offset_of!(rte_mbuf__bindgen_ty_2__bindgen_ty_1, fdir) - 0usize];
    ["Offset of field: rte_mbuf__bindgen_ty_2__bindgen_ty_1::sched"]
        [::core::mem::offset_of!(rte_mbuf__bindgen_ty_2__bindgen_ty_1, sched) - 0usize];
    ["Offset of field: rte_mbuf__bindgen_ty_2__bindgen_ty_1::txadapter"]
        [::core::mem::offset_of!(rte_mbuf__bindgen_ty_2__bindgen_ty_1, txadapter) - 0usize];
    ["Offset of field: rte_mbuf__bindgen_ty_2__bindgen_ty_1::usr"]
        [::core::mem::offset_of!(rte_mbuf__bindgen_ty_2__bindgen_ty_1, usr) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_2"][::core::mem::size_of::<rte_mbuf__bindgen_ty_2>() - 8usize];
    ["Alignment of rte_mbuf__bindgen_ty_2"]
        [::core::mem::align_of::<rte_mbuf__bindgen_ty_2>() - 4usize];
    ["Offset of field: rte_mbuf__bindgen_ty_2::hash"]
        [::core::mem::offset_of!(rte_mbuf__bindgen_ty_2, hash) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_3 {
    pub tx_offload: u64,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_3__bindgen_ty_1"]
        [::core::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>() - 8usize];
    ["Alignment of rte_mbuf__bindgen_ty_3__bindgen_ty_1"]
        [::core::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>() - 8usize];
};
impl rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn l2_len(&self) -> u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l2_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                7u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l2_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l3_len(&self) -> u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                9u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l3_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l4_len(&self) -> u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_l4_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l4_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l4_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tso_segsz(&self) -> u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_tso_segsz(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tso_segsz_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                16u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_tso_segsz_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outer_l3_len(&self) -> u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outer_l3_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                9u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_outer_l3_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outer_l2_len(&self) -> u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(49usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(49usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outer_l2_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                49usize,
                7u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_outer_l2_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                49usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_len: u64,
        l3_len: u64,
        l4_len: u64,
        tso_segsz: u64,
        outer_l3_len: u64,
        outer_l2_len: u64,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let l2_len: u64 = unsafe { ::core::mem::transmute(l2_len) };
            l2_len as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let l3_len: u64 = unsafe { ::core::mem::transmute(l3_len) };
            l3_len as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let l4_len: u64 = unsafe { ::core::mem::transmute(l4_len) };
            l4_len as u64
        });
        __bindgen_bitfield_unit.set(24usize, 16u8, {
            let tso_segsz: u64 = unsafe { ::core::mem::transmute(tso_segsz) };
            tso_segsz as u64
        });
        __bindgen_bitfield_unit.set(40usize, 9u8, {
            let outer_l3_len: u64 = unsafe { ::core::mem::transmute(outer_l3_len) };
            outer_l3_len as u64
        });
        __bindgen_bitfield_unit.set(49usize, 7u8, {
            let outer_l2_len: u64 = unsafe { ::core::mem::transmute(outer_l2_len) };
            outer_l2_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_3"][::core::mem::size_of::<rte_mbuf__bindgen_ty_3>() - 8usize];
    ["Alignment of rte_mbuf__bindgen_ty_3"]
        [::core::mem::align_of::<rte_mbuf__bindgen_ty_3>() - 8usize];
    ["Offset of field: rte_mbuf__bindgen_ty_3::tx_offload"]
        [::core::mem::offset_of!(rte_mbuf__bindgen_ty_3, tx_offload) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf"][::core::mem::size_of::<rte_mbuf>() - 128usize];
    ["Alignment of rte_mbuf"][::core::mem::align_of::<rte_mbuf>() - 64usize];
    ["Offset of field: rte_mbuf::cacheline0"]
        [::core::mem::offset_of!(rte_mbuf, cacheline0) - 0usize];
    ["Offset of field: rte_mbuf::buf_addr"][::core::mem::offset_of!(rte_mbuf, buf_addr) - 0usize];
    ["Offset of field: rte_mbuf::buf_iova"][::core::mem::offset_of!(rte_mbuf, buf_iova) - 8usize];
    ["Offset of field: rte_mbuf::rearm_data"]
        [::core::mem::offset_of!(rte_mbuf, rearm_data) - 16usize];
    ["Offset of field: rte_mbuf::data_off"][::core::mem::offset_of!(rte_mbuf, data_off) - 16usize];
    ["Offset of field: rte_mbuf::refcnt"][::core::mem::offset_of!(rte_mbuf, refcnt) - 18usize];
    ["Offset of field: rte_mbuf::nb_segs"][::core::mem::offset_of!(rte_mbuf, nb_segs) - 20usize];
    ["Offset of field: rte_mbuf::port"][::core::mem::offset_of!(rte_mbuf, port) - 22usize];
    ["Offset of field: rte_mbuf::ol_flags"][::core::mem::offset_of!(rte_mbuf, ol_flags) - 24usize];
    ["Offset of field: rte_mbuf::rx_descriptor_fields1"]
        [::core::mem::offset_of!(rte_mbuf, rx_descriptor_fields1) - 32usize];
    ["Offset of field: rte_mbuf::pkt_len"][::core::mem::offset_of!(rte_mbuf, pkt_len) - 36usize];
    ["Offset of field: rte_mbuf::data_len"][::core::mem::offset_of!(rte_mbuf, data_len) - 40usize];
    ["Offset of field: rte_mbuf::vlan_tci"][::core::mem::offset_of!(rte_mbuf, vlan_tci) - 42usize];
    ["Offset of field: rte_mbuf::vlan_tci_outer"]
        [::core::mem::offset_of!(rte_mbuf, vlan_tci_outer) - 52usize];
    ["Offset of field: rte_mbuf::buf_len"][::core::mem::offset_of!(rte_mbuf, buf_len) - 54usize];
    ["Offset of field: rte_mbuf::pool"][::core::mem::offset_of!(rte_mbuf, pool) - 56usize];
    ["Offset of field: rte_mbuf::cacheline1"]
        [::core::mem::offset_of!(rte_mbuf, cacheline1) - 64usize];
    ["Offset of field: rte_mbuf::next"][::core::mem::offset_of!(rte_mbuf, next) - 64usize];
    ["Offset of field: rte_mbuf::shinfo"][::core::mem::offset_of!(rte_mbuf, shinfo) - 80usize];
    ["Offset of field: rte_mbuf::priv_size"]
        [::core::mem::offset_of!(rte_mbuf, priv_size) - 88usize];
    ["Offset of field: rte_mbuf::timesync"][::core::mem::offset_of!(rte_mbuf, timesync) - 90usize];
    ["Offset of field: rte_mbuf::dynfield1"]
        [::core::mem::offset_of!(rte_mbuf, dynfield1) - 92usize];
};
pub type rte_mbuf_extbuf_free_callback_t = ::core::option::Option<
    unsafe extern "C" fn(addr: *mut ::core::ffi::c_void, opaque: *mut ::core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf_ext_shared_info {
    pub free_cb: rte_mbuf_extbuf_free_callback_t,
    pub fcb_opaque: *mut ::core::ffi::c_void,
    pub refcnt: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf_ext_shared_info"]
        [::core::mem::size_of::<rte_mbuf_ext_shared_info>() - 24usize];
    ["Alignment of rte_mbuf_ext_shared_info"]
        [::core::mem::align_of::<rte_mbuf_ext_shared_info>() - 8usize];
    ["Offset of field: rte_mbuf_ext_shared_info::free_cb"]
        [::core::mem::offset_of!(rte_mbuf_ext_shared_info, free_cb) - 0usize];
    ["Offset of field: rte_mbuf_ext_shared_info::fcb_opaque"]
        [::core::mem::offset_of!(rte_mbuf_ext_shared_info, fcb_opaque) - 8usize];
    ["Offset of field: rte_mbuf_ext_shared_info::refcnt"]
        [::core::mem::offset_of!(rte_mbuf_ext_shared_info, refcnt) - 16usize];
};
unsafe extern "C" {
    pub fn rte_pktmbuf_pool_create(
        name: *const ::core::ffi::c_char,
        n: ::core::ffi::c_uint,
        cache_size: ::core::ffi::c_uint,
        priv_size: u16,
        data_room_size: u16,
        socket_id: ::core::ffi::c_int,
    ) -> *mut rte_mempool;
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct rte_ether_addr {
    pub addr_bytes: [u8; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_ether_addr"][::core::mem::size_of::<rte_ether_addr>() - 6usize];
    ["Alignment of rte_ether_addr"][::core::mem::align_of::<rte_ether_addr>() - 2usize];
    ["Offset of field: rte_ether_addr::addr_bytes"]
        [::core::mem::offset_of!(rte_ether_addr, addr_bytes) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ether_hdr {
    pub dst_addr: rte_ether_addr,
    pub src_addr: rte_ether_addr,
    pub ether_type: rte_be16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_ether_hdr"][::core::mem::size_of::<rte_ether_hdr>() - 14usize];
    ["Alignment of rte_ether_hdr"][::core::mem::align_of::<rte_ether_hdr>() - 2usize];
    ["Offset of field: rte_ether_hdr::dst_addr"]
        [::core::mem::offset_of!(rte_ether_hdr, dst_addr) - 0usize];
    ["Offset of field: rte_ether_hdr::src_addr"]
        [::core::mem::offset_of!(rte_ether_hdr, src_addr) - 6usize];
    ["Offset of field: rte_ether_hdr::ether_type"]
        [::core::mem::offset_of!(rte_ether_hdr, ether_type) - 12usize];
};
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_ipv4_hdr {
    pub __bindgen_anon_1: rte_ipv4_hdr__bindgen_ty_1,
    pub type_of_service: u8,
    pub total_length: rte_be16_t,
    pub packet_id: rte_be16_t,
    pub fragment_offset: rte_be16_t,
    pub time_to_live: u8,
    pub next_proto_id: u8,
    pub hdr_checksum: rte_be16_t,
    pub src_addr: rte_be32_t,
    pub dst_addr: rte_be32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_ipv4_hdr__bindgen_ty_1 {
    pub version_ihl: u8,
    pub __bindgen_anon_1: rte_ipv4_hdr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ipv4_hdr__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_ipv4_hdr__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<rte_ipv4_hdr__bindgen_ty_1__bindgen_ty_1>() - 1usize];
    ["Alignment of rte_ipv4_hdr__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<rte_ipv4_hdr__bindgen_ty_1__bindgen_ty_1>() - 1usize];
};
impl rte_ipv4_hdr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ihl(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ihl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ihl_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ihl_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn version(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_version(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn version_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_version_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(ihl: u8, version: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ihl: u8 = unsafe { ::core::mem::transmute(ihl) };
            ihl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let version: u8 = unsafe { ::core::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_ipv4_hdr__bindgen_ty_1"]
        [::core::mem::size_of::<rte_ipv4_hdr__bindgen_ty_1>() - 1usize];
    ["Alignment of rte_ipv4_hdr__bindgen_ty_1"]
        [::core::mem::align_of::<rte_ipv4_hdr__bindgen_ty_1>() - 1usize];
    ["Offset of field: rte_ipv4_hdr__bindgen_ty_1::version_ihl"]
        [::core::mem::offset_of!(rte_ipv4_hdr__bindgen_ty_1, version_ihl) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_ipv4_hdr"][::core::mem::size_of::<rte_ipv4_hdr>() - 20usize];
    ["Alignment of rte_ipv4_hdr"][::core::mem::align_of::<rte_ipv4_hdr>() - 1usize];
    ["Offset of field: rte_ipv4_hdr::type_of_service"]
        [::core::mem::offset_of!(rte_ipv4_hdr, type_of_service) - 1usize];
    ["Offset of field: rte_ipv4_hdr::total_length"]
        [::core::mem::offset_of!(rte_ipv4_hdr, total_length) - 2usize];
    ["Offset of field: rte_ipv4_hdr::packet_id"]
        [::core::mem::offset_of!(rte_ipv4_hdr, packet_id) - 4usize];
    ["Offset of field: rte_ipv4_hdr::fragment_offset"]
        [::core::mem::offset_of!(rte_ipv4_hdr, fragment_offset) - 6usize];
    ["Offset of field: rte_ipv4_hdr::time_to_live"]
        [::core::mem::offset_of!(rte_ipv4_hdr, time_to_live) - 8usize];
    ["Offset of field: rte_ipv4_hdr::next_proto_id"]
        [::core::mem::offset_of!(rte_ipv4_hdr, next_proto_id) - 9usize];
    ["Offset of field: rte_ipv4_hdr::hdr_checksum"]
        [::core::mem::offset_of!(rte_ipv4_hdr, hdr_checksum) - 10usize];
    ["Offset of field: rte_ipv4_hdr::src_addr"]
        [::core::mem::offset_of!(rte_ipv4_hdr, src_addr) - 12usize];
    ["Offset of field: rte_ipv4_hdr::dst_addr"]
        [::core::mem::offset_of!(rte_ipv4_hdr, dst_addr) - 16usize];
};
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ipv6_hdr {
    pub vtc_flow: rte_be32_t,
    pub payload_len: rte_be16_t,
    pub proto: u8,
    pub hop_limits: u8,
    pub src_addr: [u8; 16usize],
    pub dst_addr: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_ipv6_hdr"][::core::mem::size_of::<rte_ipv6_hdr>() - 40usize];
    ["Alignment of rte_ipv6_hdr"][::core::mem::align_of::<rte_ipv6_hdr>() - 1usize];
    ["Offset of field: rte_ipv6_hdr::vtc_flow"]
        [::core::mem::offset_of!(rte_ipv6_hdr, vtc_flow) - 0usize];
    ["Offset of field: rte_ipv6_hdr::payload_len"]
        [::core::mem::offset_of!(rte_ipv6_hdr, payload_len) - 4usize];
    ["Offset of field: rte_ipv6_hdr::proto"][::core::mem::offset_of!(rte_ipv6_hdr, proto) - 6usize];
    ["Offset of field: rte_ipv6_hdr::hop_limits"]
        [::core::mem::offset_of!(rte_ipv6_hdr, hop_limits) - 7usize];
    ["Offset of field: rte_ipv6_hdr::src_addr"]
        [::core::mem::offset_of!(rte_ipv6_hdr, src_addr) - 8usize];
    ["Offset of field: rte_ipv6_hdr::dst_addr"]
        [::core::mem::offset_of!(rte_ipv6_hdr, dst_addr) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_attr {
    pub group: u32,
    pub priority: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_attr"][::core::mem::size_of::<rte_flow_attr>() - 12usize];
    ["Alignment of rte_flow_attr"][::core::mem::align_of::<rte_flow_attr>() - 4usize];
    ["Offset of field: rte_flow_attr::group"]
        [::core::mem::offset_of!(rte_flow_attr, group) - 0usize];
    ["Offset of field: rte_flow_attr::priority"]
        [::core::mem::offset_of!(rte_flow_attr, priority) - 4usize];
};
impl rte_flow_attr {
    #[inline]
    pub fn ingress(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ingress_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ingress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn egress_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_egress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn transfer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transfer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transfer_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_transfer_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ingress: u32,
        egress: u32,
        transfer: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ingress: u32 = unsafe { ::core::mem::transmute(ingress) };
            ingress as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let egress: u32 = unsafe { ::core::mem::transmute(egress) };
            egress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let transfer: u32 = unsafe { ::core::mem::transmute(transfer) };
            transfer as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_END: rte_flow_item_type = 0;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_VOID: rte_flow_item_type = 1;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_INVERT: rte_flow_item_type = 2;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ANY: rte_flow_item_type = 3;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PORT_ID: rte_flow_item_type = 4;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_RAW: rte_flow_item_type = 5;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ETH: rte_flow_item_type = 6;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_VLAN: rte_flow_item_type = 7;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV4: rte_flow_item_type = 8;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV6: rte_flow_item_type = 9;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP: rte_flow_item_type = 10;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_UDP: rte_flow_item_type = 11;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_TCP: rte_flow_item_type = 12;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_SCTP: rte_flow_item_type = 13;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_VXLAN: rte_flow_item_type = 14;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_E_TAG: rte_flow_item_type = 15;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_NVGRE: rte_flow_item_type = 16;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_MPLS: rte_flow_item_type = 17;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GRE: rte_flow_item_type = 18;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_FUZZY: rte_flow_item_type = 19;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GTP: rte_flow_item_type = 20;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GTPC: rte_flow_item_type = 21;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GTPU: rte_flow_item_type = 22;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ESP: rte_flow_item_type = 23;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GENEVE: rte_flow_item_type = 24;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_VXLAN_GPE: rte_flow_item_type = 25;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ARP_ETH_IPV4: rte_flow_item_type = 26;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV6_EXT: rte_flow_item_type = 27;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6: rte_flow_item_type = 28;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS: rte_flow_item_type = 29;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA: rte_flow_item_type = 30;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT: rte_flow_item_type = 31;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_SLA_ETH: rte_flow_item_type = 32;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_TLA_ETH: rte_flow_item_type = 33;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_MARK: rte_flow_item_type = 34;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_META: rte_flow_item_type = 35;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GRE_KEY: rte_flow_item_type = 36;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GTP_PSC: rte_flow_item_type = 37;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PPPOES: rte_flow_item_type = 38;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PPPOED: rte_flow_item_type = 39;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PPPOE_PROTO_ID: rte_flow_item_type = 40;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_NSH: rte_flow_item_type = 41;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IGMP: rte_flow_item_type = 42;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_AH: rte_flow_item_type = 43;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_HIGIG2: rte_flow_item_type = 44;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_TAG: rte_flow_item_type = 45;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_L2TPV3OIP: rte_flow_item_type = 46;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PFCP: rte_flow_item_type = 47;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ECPRI: rte_flow_item_type = 48;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV6_FRAG_EXT: rte_flow_item_type = 49;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GENEVE_OPT: rte_flow_item_type = 50;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_INTEGRITY: rte_flow_item_type = 51;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_CONNTRACK: rte_flow_item_type = 52;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR: rte_flow_item_type = 53;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT: rte_flow_item_type = 54;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_FLEX: rte_flow_item_type = 55;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_L2TPV2: rte_flow_item_type = 56;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PPP: rte_flow_item_type = 57;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GRE_OPTION: rte_flow_item_type = 58;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_MACSEC: rte_flow_item_type = 59;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_METER_COLOR: rte_flow_item_type = 60;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV6_ROUTING_EXT: rte_flow_item_type = 61;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ECHO_REQUEST: rte_flow_item_type = 62;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ECHO_REPLY: rte_flow_item_type = 63;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_QUOTA: rte_flow_item_type = 64;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_AGGR_AFFINITY: rte_flow_item_type = 65;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_TX_QUEUE: rte_flow_item_type = 66;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IB_BTH: rte_flow_item_type = 67;
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PTYPE: rte_flow_item_type = 68;
pub type rte_flow_item_type = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_eth {
    pub __bindgen_anon_1: rte_flow_item_eth__bindgen_ty_1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_item_eth__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_flow_item_eth__bindgen_ty_1__bindgen_ty_1,
    pub hdr: rte_ether_hdr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_eth__bindgen_ty_1__bindgen_ty_1 {
    pub dst: rte_ether_addr,
    pub src: rte_ether_addr,
    pub type_: rte_be16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_eth__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<rte_flow_item_eth__bindgen_ty_1__bindgen_ty_1>() - 14usize];
    ["Alignment of rte_flow_item_eth__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<rte_flow_item_eth__bindgen_ty_1__bindgen_ty_1>() - 2usize];
    ["Offset of field: rte_flow_item_eth__bindgen_ty_1__bindgen_ty_1::dst"]
        [::core::mem::offset_of!(rte_flow_item_eth__bindgen_ty_1__bindgen_ty_1, dst) - 0usize];
    ["Offset of field: rte_flow_item_eth__bindgen_ty_1__bindgen_ty_1::src"]
        [::core::mem::offset_of!(rte_flow_item_eth__bindgen_ty_1__bindgen_ty_1, src) - 6usize];
    ["Offset of field: rte_flow_item_eth__bindgen_ty_1__bindgen_ty_1::type_"]
        [::core::mem::offset_of!(rte_flow_item_eth__bindgen_ty_1__bindgen_ty_1, type_) - 12usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_eth__bindgen_ty_1"]
        [::core::mem::size_of::<rte_flow_item_eth__bindgen_ty_1>() - 14usize];
    ["Alignment of rte_flow_item_eth__bindgen_ty_1"]
        [::core::mem::align_of::<rte_flow_item_eth__bindgen_ty_1>() - 2usize];
    ["Offset of field: rte_flow_item_eth__bindgen_ty_1::hdr"]
        [::core::mem::offset_of!(rte_flow_item_eth__bindgen_ty_1, hdr) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_eth"][::core::mem::size_of::<rte_flow_item_eth>() - 20usize];
    ["Alignment of rte_flow_item_eth"][::core::mem::align_of::<rte_flow_item_eth>() - 4usize];
};
impl rte_flow_item_eth {
    #[inline]
    pub fn has_vlan(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_vlan(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_vlan_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_vlan_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(has_vlan: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_vlan: u32 = unsafe { ::core::mem::transmute(has_vlan) };
            has_vlan as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_ipv4 {
    pub hdr: rte_ipv4_hdr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_ipv4"][::core::mem::size_of::<rte_flow_item_ipv4>() - 20usize];
    ["Alignment of rte_flow_item_ipv4"][::core::mem::align_of::<rte_flow_item_ipv4>() - 1usize];
    ["Offset of field: rte_flow_item_ipv4::hdr"]
        [::core::mem::offset_of!(rte_flow_item_ipv4, hdr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_ipv6 {
    pub hdr: rte_ipv6_hdr,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_ipv6"][::core::mem::size_of::<rte_flow_item_ipv6>() - 44usize];
    ["Alignment of rte_flow_item_ipv6"][::core::mem::align_of::<rte_flow_item_ipv6>() - 4usize];
    ["Offset of field: rte_flow_item_ipv6::hdr"]
        [::core::mem::offset_of!(rte_flow_item_ipv6, hdr) - 0usize];
};
impl rte_flow_item_ipv6 {
    #[inline]
    pub fn has_hop_ext(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_hop_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_hop_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_hop_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_route_ext(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_route_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_route_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_route_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_frag_ext(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_frag_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_frag_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_frag_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_auth_ext(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_auth_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_auth_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_auth_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_esp_ext(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_esp_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_esp_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_esp_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_dest_ext(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_dest_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_dest_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_dest_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_mobil_ext(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_mobil_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_mobil_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_mobil_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_hip_ext(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_hip_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_hip_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_hip_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_shim6_ext(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_shim6_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_shim6_ext_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_shim6_ext_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                23u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                23u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        has_hop_ext: u32,
        has_route_ext: u32,
        has_frag_ext: u32,
        has_auth_ext: u32,
        has_esp_ext: u32,
        has_dest_ext: u32,
        has_mobil_ext: u32,
        has_hip_ext: u32,
        has_shim6_ext: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_hop_ext: u32 = unsafe { ::core::mem::transmute(has_hop_ext) };
            has_hop_ext as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_route_ext: u32 = unsafe { ::core::mem::transmute(has_route_ext) };
            has_route_ext as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let has_frag_ext: u32 = unsafe { ::core::mem::transmute(has_frag_ext) };
            has_frag_ext as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let has_auth_ext: u32 = unsafe { ::core::mem::transmute(has_auth_ext) };
            has_auth_ext as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let has_esp_ext: u32 = unsafe { ::core::mem::transmute(has_esp_ext) };
            has_esp_ext as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let has_dest_ext: u32 = unsafe { ::core::mem::transmute(has_dest_ext) };
            has_dest_ext as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let has_mobil_ext: u32 = unsafe { ::core::mem::transmute(has_mobil_ext) };
            has_mobil_ext as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let has_hip_ext: u32 = unsafe { ::core::mem::transmute(has_hip_ext) };
            has_hip_ext as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let has_shim6_ext: u32 = unsafe { ::core::mem::transmute(has_shim6_ext) };
            has_shim6_ext as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item {
    pub type_: rte_flow_item_type,
    pub spec: *const ::core::ffi::c_void,
    pub last: *const ::core::ffi::c_void,
    pub mask: *const ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item"][::core::mem::size_of::<rte_flow_item>() - 32usize];
    ["Alignment of rte_flow_item"][::core::mem::align_of::<rte_flow_item>() - 8usize];
    ["Offset of field: rte_flow_item::type_"]
        [::core::mem::offset_of!(rte_flow_item, type_) - 0usize];
    ["Offset of field: rte_flow_item::spec"][::core::mem::offset_of!(rte_flow_item, spec) - 8usize];
    ["Offset of field: rte_flow_item::last"]
        [::core::mem::offset_of!(rte_flow_item, last) - 16usize];
    ["Offset of field: rte_flow_item::mask"]
        [::core::mem::offset_of!(rte_flow_item, mask) - 24usize];
};
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_END: rte_flow_action_type = 0;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_VOID: rte_flow_action_type = 1;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PASSTHRU: rte_flow_action_type = 2;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_JUMP: rte_flow_action_type = 3;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_MARK: rte_flow_action_type = 4;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_FLAG: rte_flow_action_type = 5;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_QUEUE: rte_flow_action_type = 6;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_DROP: rte_flow_action_type = 7;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_COUNT: rte_flow_action_type = 8;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_RSS: rte_flow_action_type = 9;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PF: rte_flow_action_type = 10;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_VF: rte_flow_action_type = 11;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PORT_ID: rte_flow_action_type = 12;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_METER: rte_flow_action_type = 13;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SECURITY: rte_flow_action_type = 14;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_DEC_NW_TTL: rte_flow_action_type = 15;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_POP_VLAN: rte_flow_action_type = 16;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_PUSH_VLAN: rte_flow_action_type = 17;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_VID: rte_flow_action_type = 18;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_PCP: rte_flow_action_type = 19;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_POP_MPLS: rte_flow_action_type = 20;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_PUSH_MPLS: rte_flow_action_type = 21;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_VXLAN_ENCAP: rte_flow_action_type = 22;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_VXLAN_DECAP: rte_flow_action_type = 23;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_NVGRE_ENCAP: rte_flow_action_type = 24;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_NVGRE_DECAP: rte_flow_action_type = 25;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_RAW_ENCAP: rte_flow_action_type = 26;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_RAW_DECAP: rte_flow_action_type = 27;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV4_SRC: rte_flow_action_type = 28;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV4_DST: rte_flow_action_type = 29;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV6_SRC: rte_flow_action_type = 30;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV6_DST: rte_flow_action_type = 31;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_TP_SRC: rte_flow_action_type = 32;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_TP_DST: rte_flow_action_type = 33;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_MAC_SWAP: rte_flow_action_type = 34;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_DEC_TTL: rte_flow_action_type = 35;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_TTL: rte_flow_action_type = 36;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_MAC_SRC: rte_flow_action_type = 37;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_MAC_DST: rte_flow_action_type = 38;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_INC_TCP_SEQ: rte_flow_action_type = 39;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_DEC_TCP_SEQ: rte_flow_action_type = 40;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_INC_TCP_ACK: rte_flow_action_type = 41;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_DEC_TCP_ACK: rte_flow_action_type = 42;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_TAG: rte_flow_action_type = 43;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_META: rte_flow_action_type = 44;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV4_DSCP: rte_flow_action_type = 45;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV6_DSCP: rte_flow_action_type = 46;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_AGE: rte_flow_action_type = 47;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SAMPLE: rte_flow_action_type = 48;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SHARED: rte_flow_action_type = 49;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_MODIFY_FIELD: rte_flow_action_type = 50;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_INDIRECT: rte_flow_action_type = 51;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_CONNTRACK: rte_flow_action_type = 52;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_METER_COLOR: rte_flow_action_type = 53;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR: rte_flow_action_type = 54;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT: rte_flow_action_type = 55;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_METER_MARK: rte_flow_action_type = 56;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SEND_TO_KERNEL: rte_flow_action_type = 57;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_QUOTA: rte_flow_action_type = 58;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SKIP_CMAN: rte_flow_action_type = 59;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_IPV6_EXT_PUSH: rte_flow_action_type = 60;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_IPV6_EXT_REMOVE: rte_flow_action_type = 61;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_INDIRECT_LIST: rte_flow_action_type = 62;
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PROG: rte_flow_action_type = 63;
pub type rte_flow_action_type = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_queue {
    pub index: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_queue"][::core::mem::size_of::<rte_flow_action_queue>() - 2usize];
    ["Alignment of rte_flow_action_queue"]
        [::core::mem::align_of::<rte_flow_action_queue>() - 2usize];
    ["Offset of field: rte_flow_action_queue::index"]
        [::core::mem::offset_of!(rte_flow_action_queue, index) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action {
    pub type_: rte_flow_action_type,
    pub conf: *const ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action"][::core::mem::size_of::<rte_flow_action>() - 16usize];
    ["Alignment of rte_flow_action"][::core::mem::align_of::<rte_flow_action>() - 8usize];
    ["Offset of field: rte_flow_action::type_"]
        [::core::mem::offset_of!(rte_flow_action, type_) - 0usize];
    ["Offset of field: rte_flow_action::conf"]
        [::core::mem::offset_of!(rte_flow_action, conf) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow {
    _unused: [u8; 0],
}
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_NONE: rte_flow_error_type = 0;
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_UNSPECIFIED: rte_flow_error_type = 1;
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_HANDLE: rte_flow_error_type = 2;
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR_GROUP: rte_flow_error_type = 3;
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR_PRIORITY: rte_flow_error_type = 4;
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR_INGRESS: rte_flow_error_type = 5;
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR_EGRESS: rte_flow_error_type = 6;
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR_TRANSFER: rte_flow_error_type = 7;
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR: rte_flow_error_type = 8;
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ITEM_NUM: rte_flow_error_type = 9;
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ITEM_SPEC: rte_flow_error_type = 10;
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ITEM_LAST: rte_flow_error_type = 11;
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ITEM_MASK: rte_flow_error_type = 12;
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ITEM: rte_flow_error_type = 13;
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ACTION_NUM: rte_flow_error_type = 14;
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ACTION_CONF: rte_flow_error_type = 15;
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ACTION: rte_flow_error_type = 16;
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_STATE: rte_flow_error_type = 17;
pub type rte_flow_error_type = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_error {
    pub type_: rte_flow_error_type,
    pub cause: *const ::core::ffi::c_void,
    pub message: *const ::core::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_error"][::core::mem::size_of::<rte_flow_error>() - 24usize];
    ["Alignment of rte_flow_error"][::core::mem::align_of::<rte_flow_error>() - 8usize];
    ["Offset of field: rte_flow_error::type_"]
        [::core::mem::offset_of!(rte_flow_error, type_) - 0usize];
    ["Offset of field: rte_flow_error::cause"]
        [::core::mem::offset_of!(rte_flow_error, cause) - 8usize];
    ["Offset of field: rte_flow_error::message"]
        [::core::mem::offset_of!(rte_flow_error, message) - 16usize];
};
unsafe extern "C" {
    pub fn rte_flow_validate(
        port_id: u16,
        attr: *const rte_flow_attr,
        pattern: *const rte_flow_item,
        actions: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn rte_flow_create(
        port_id: u16,
        attr: *const rte_flow_attr,
        pattern: *const rte_flow_item,
        actions: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow;
}
unsafe extern "C" {
    pub fn rte_flow_destroy(
        port_id: u16,
        flow: *mut rte_flow,
        error: *mut rte_flow_error,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn rte_flow_flush(port_id: u16, error: *mut rte_flow_error) -> ::core::ffi::c_int;
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_intr_conf {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_intr_conf"][::core::mem::size_of::<rte_eth_intr_conf>() - 4usize];
    ["Alignment of rte_eth_intr_conf"][::core::mem::align_of::<rte_eth_intr_conf>() - 4usize];
};
impl rte_eth_intr_conf {
    #[inline]
    pub fn lsc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lsc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lsc_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lsc_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rxq(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rxq_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rxq_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rmv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rmv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rmv_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rmv_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(lsc: u32, rxq: u32, rmv: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lsc: u32 = unsafe { ::core::mem::transmute(lsc) };
            lsc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rxq: u32 = unsafe { ::core::mem::transmute(rxq) };
            rxq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rmv: u32 = unsafe { ::core::mem::transmute(rmv) };
            rmv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_conf {
    pub link_speeds: u32,
    pub rxmode: rte_eth_rxmode,
    pub txmode: rte_eth_txmode,
    pub lpbk_mode: u32,
    pub rx_adv_conf: rte_eth_conf__bindgen_ty_1,
    pub tx_adv_conf: rte_eth_conf__bindgen_ty_2,
    pub dcb_capability_en: u32,
    pub intr_conf: rte_eth_intr_conf,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_conf__bindgen_ty_1 {
    pub rss_conf: rte_eth_rss_conf,
    pub vmdq_dcb_conf: rte_eth_vmdq_dcb_conf,
    pub dcb_rx_conf: rte_eth_dcb_rx_conf,
    pub vmdq_rx_conf: rte_eth_vmdq_rx_conf,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_conf__bindgen_ty_1"]
        [::core::mem::size_of::<rte_eth_conf__bindgen_ty_1>() - 2128usize];
    ["Alignment of rte_eth_conf__bindgen_ty_1"]
        [::core::mem::align_of::<rte_eth_conf__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_eth_conf__bindgen_ty_1::rss_conf"]
        [::core::mem::offset_of!(rte_eth_conf__bindgen_ty_1, rss_conf) - 0usize];
    ["Offset of field: rte_eth_conf__bindgen_ty_1::vmdq_dcb_conf"]
        [::core::mem::offset_of!(rte_eth_conf__bindgen_ty_1, vmdq_dcb_conf) - 32usize];
    ["Offset of field: rte_eth_conf__bindgen_ty_1::dcb_rx_conf"]
        [::core::mem::offset_of!(rte_eth_conf__bindgen_ty_1, dcb_rx_conf) - 1072usize];
    ["Offset of field: rte_eth_conf__bindgen_ty_1::vmdq_rx_conf"]
        [::core::mem::offset_of!(rte_eth_conf__bindgen_ty_1, vmdq_rx_conf) - 1088usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_conf__bindgen_ty_2 {
    pub vmdq_dcb_tx_conf: rte_eth_vmdq_dcb_tx_conf,
    pub dcb_tx_conf: rte_eth_dcb_tx_conf,
    pub vmdq_tx_conf: rte_eth_vmdq_tx_conf,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_conf__bindgen_ty_2"]
        [::core::mem::size_of::<rte_eth_conf__bindgen_ty_2>() - 12usize];
    ["Alignment of rte_eth_conf__bindgen_ty_2"]
        [::core::mem::align_of::<rte_eth_conf__bindgen_ty_2>() - 4usize];
    ["Offset of field: rte_eth_conf__bindgen_ty_2::vmdq_dcb_tx_conf"]
        [::core::mem::offset_of!(rte_eth_conf__bindgen_ty_2, vmdq_dcb_tx_conf) - 0usize];
    ["Offset of field: rte_eth_conf__bindgen_ty_2::dcb_tx_conf"]
        [::core::mem::offset_of!(rte_eth_conf__bindgen_ty_2, dcb_tx_conf) - 0usize];
    ["Offset of field: rte_eth_conf__bindgen_ty_2::vmdq_tx_conf"]
        [::core::mem::offset_of!(rte_eth_conf__bindgen_ty_2, vmdq_tx_conf) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_conf"][::core::mem::size_of::<rte_eth_conf>() - 2280usize];
    ["Alignment of rte_eth_conf"][::core::mem::align_of::<rte_eth_conf>() - 8usize];
    ["Offset of field: rte_eth_conf::link_speeds"]
        [::core::mem::offset_of!(rte_eth_conf, link_speeds) - 0usize];
    ["Offset of field: rte_eth_conf::rxmode"]
        [::core::mem::offset_of!(rte_eth_conf, rxmode) - 8usize];
    ["Offset of field: rte_eth_conf::txmode"]
        [::core::mem::offset_of!(rte_eth_conf, txmode) - 64usize];
    ["Offset of field: rte_eth_conf::lpbk_mode"]
        [::core::mem::offset_of!(rte_eth_conf, lpbk_mode) - 120usize];
    ["Offset of field: rte_eth_conf::rx_adv_conf"]
        [::core::mem::offset_of!(rte_eth_conf, rx_adv_conf) - 128usize];
    ["Offset of field: rte_eth_conf::tx_adv_conf"]
        [::core::mem::offset_of!(rte_eth_conf, tx_adv_conf) - 2256usize];
    ["Offset of field: rte_eth_conf::dcb_capability_en"]
        [::core::mem::offset_of!(rte_eth_conf, dcb_capability_en) - 2268usize];
    ["Offset of field: rte_eth_conf::intr_conf"]
        [::core::mem::offset_of!(rte_eth_conf, intr_conf) - 2272usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_portconf {
    pub burst_size: u16,
    pub ring_size: u16,
    pub nb_queues: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_dev_portconf"][::core::mem::size_of::<rte_eth_dev_portconf>() - 6usize];
    ["Alignment of rte_eth_dev_portconf"][::core::mem::align_of::<rte_eth_dev_portconf>() - 2usize];
    ["Offset of field: rte_eth_dev_portconf::burst_size"]
        [::core::mem::offset_of!(rte_eth_dev_portconf, burst_size) - 0usize];
    ["Offset of field: rte_eth_dev_portconf::ring_size"]
        [::core::mem::offset_of!(rte_eth_dev_portconf, ring_size) - 2usize];
    ["Offset of field: rte_eth_dev_portconf::nb_queues"]
        [::core::mem::offset_of!(rte_eth_dev_portconf, nb_queues) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_switch_info {
    pub name: *const ::core::ffi::c_char,
    pub domain_id: u16,
    pub port_id: u16,
    pub rx_domain: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_switch_info"][::core::mem::size_of::<rte_eth_switch_info>() - 16usize];
    ["Alignment of rte_eth_switch_info"][::core::mem::align_of::<rte_eth_switch_info>() - 8usize];
    ["Offset of field: rte_eth_switch_info::name"]
        [::core::mem::offset_of!(rte_eth_switch_info, name) - 0usize];
    ["Offset of field: rte_eth_switch_info::domain_id"]
        [::core::mem::offset_of!(rte_eth_switch_info, domain_id) - 8usize];
    ["Offset of field: rte_eth_switch_info::port_id"]
        [::core::mem::offset_of!(rte_eth_switch_info, port_id) - 10usize];
    ["Offset of field: rte_eth_switch_info::rx_domain"]
        [::core::mem::offset_of!(rte_eth_switch_info, rx_domain) - 12usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rxseg_capa {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub max_nseg: u16,
    pub reserved: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_rxseg_capa"][::core::mem::size_of::<rte_eth_rxseg_capa>() - 8usize];
    ["Alignment of rte_eth_rxseg_capa"][::core::mem::align_of::<rte_eth_rxseg_capa>() - 4usize];
    ["Offset of field: rte_eth_rxseg_capa::max_nseg"]
        [::core::mem::offset_of!(rte_eth_rxseg_capa, max_nseg) - 2usize];
    ["Offset of field: rte_eth_rxseg_capa::reserved"]
        [::core::mem::offset_of!(rte_eth_rxseg_capa, reserved) - 4usize];
};
impl rte_eth_rxseg_capa {
    #[inline]
    pub fn multi_pools(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_multi_pools(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn multi_pools_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_multi_pools_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn offset_allowed(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_offset_allowed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn offset_allowed_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_offset_allowed_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn offset_align_log2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_offset_align_log2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn offset_align_log2_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_offset_align_log2_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        multi_pools: u32,
        offset_allowed: u32,
        offset_align_log2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let multi_pools: u32 = unsafe { ::core::mem::transmute(multi_pools) };
            multi_pools as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let offset_allowed: u32 = unsafe { ::core::mem::transmute(offset_allowed) };
            offset_allowed as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let offset_align_log2: u32 = unsafe { ::core::mem::transmute(offset_align_log2) };
            offset_align_log2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const rte_eth_err_handle_mode_RTE_ETH_ERROR_HANDLE_MODE_NONE: rte_eth_err_handle_mode = 0;
pub const rte_eth_err_handle_mode_RTE_ETH_ERROR_HANDLE_MODE_PASSIVE: rte_eth_err_handle_mode = 1;
pub const rte_eth_err_handle_mode_RTE_ETH_ERROR_HANDLE_MODE_PROACTIVE: rte_eth_err_handle_mode = 2;
pub type rte_eth_err_handle_mode = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_info {
    pub device: *mut rte_device,
    pub driver_name: *const ::core::ffi::c_char,
    pub if_index: ::core::ffi::c_uint,
    pub min_mtu: u16,
    pub max_mtu: u16,
    pub dev_flags: *const u32,
    pub min_rx_bufsize: u32,
    pub max_rx_bufsize: u32,
    pub max_rx_pktlen: u32,
    pub max_lro_pkt_size: u32,
    pub max_rx_queues: u16,
    pub max_tx_queues: u16,
    pub max_mac_addrs: u32,
    pub max_hash_mac_addrs: u32,
    pub max_vfs: u16,
    pub max_vmdq_pools: u16,
    pub rx_seg_capa: rte_eth_rxseg_capa,
    pub rx_offload_capa: u64,
    pub tx_offload_capa: u64,
    pub rx_queue_offload_capa: u64,
    pub tx_queue_offload_capa: u64,
    pub reta_size: u16,
    pub hash_key_size: u8,
    pub rss_algo_capa: u32,
    pub flow_type_rss_offloads: u64,
    pub default_rxconf: rte_eth_rxconf,
    pub default_txconf: rte_eth_txconf,
    pub vmdq_queue_base: u16,
    pub vmdq_queue_num: u16,
    pub vmdq_pool_base: u16,
    pub rx_desc_lim: rte_eth_desc_lim,
    pub tx_desc_lim: rte_eth_desc_lim,
    pub speed_capa: u32,
    pub nb_rx_queues: u16,
    pub nb_tx_queues: u16,
    pub max_rx_mempools: u16,
    pub default_rxportconf: rte_eth_dev_portconf,
    pub default_txportconf: rte_eth_dev_portconf,
    pub dev_capa: u64,
    pub switch_info: rte_eth_switch_info,
    pub err_handle_mode: rte_eth_err_handle_mode,
    pub reserved_64s: [u64; 2usize],
    pub reserved_ptrs: [*mut ::core::ffi::c_void; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_dev_info"][::core::mem::size_of::<rte_eth_dev_info>() - 376usize];
    ["Alignment of rte_eth_dev_info"][::core::mem::align_of::<rte_eth_dev_info>() - 8usize];
    ["Offset of field: rte_eth_dev_info::device"]
        [::core::mem::offset_of!(rte_eth_dev_info, device) - 0usize];
    ["Offset of field: rte_eth_dev_info::driver_name"]
        [::core::mem::offset_of!(rte_eth_dev_info, driver_name) - 8usize];
    ["Offset of field: rte_eth_dev_info::if_index"]
        [::core::mem::offset_of!(rte_eth_dev_info, if_index) - 16usize];
    ["Offset of field: rte_eth_dev_info::min_mtu"]
        [::core::mem::offset_of!(rte_eth_dev_info, min_mtu) - 20usize];
    ["Offset of field: rte_eth_dev_info::max_mtu"]
        [::core::mem::offset_of!(rte_eth_dev_info, max_mtu) - 22usize];
    ["Offset of field: rte_eth_dev_info::dev_flags"]
        [::core::mem::offset_of!(rte_eth_dev_info, dev_flags) - 24usize];
    ["Offset of field: rte_eth_dev_info::min_rx_bufsize"]
        [::core::mem::offset_of!(rte_eth_dev_info, min_rx_bufsize) - 32usize];
    ["Offset of field: rte_eth_dev_info::max_rx_bufsize"]
        [::core::mem::offset_of!(rte_eth_dev_info, max_rx_bufsize) - 36usize];
    ["Offset of field: rte_eth_dev_info::max_rx_pktlen"]
        [::core::mem::offset_of!(rte_eth_dev_info, max_rx_pktlen) - 40usize];
    ["Offset of field: rte_eth_dev_info::max_lro_pkt_size"]
        [::core::mem::offset_of!(rte_eth_dev_info, max_lro_pkt_size) - 44usize];
    ["Offset of field: rte_eth_dev_info::max_rx_queues"]
        [::core::mem::offset_of!(rte_eth_dev_info, max_rx_queues) - 48usize];
    ["Offset of field: rte_eth_dev_info::max_tx_queues"]
        [::core::mem::offset_of!(rte_eth_dev_info, max_tx_queues) - 50usize];
    ["Offset of field: rte_eth_dev_info::max_mac_addrs"]
        [::core::mem::offset_of!(rte_eth_dev_info, max_mac_addrs) - 52usize];
    ["Offset of field: rte_eth_dev_info::max_hash_mac_addrs"]
        [::core::mem::offset_of!(rte_eth_dev_info, max_hash_mac_addrs) - 56usize];
    ["Offset of field: rte_eth_dev_info::max_vfs"]
        [::core::mem::offset_of!(rte_eth_dev_info, max_vfs) - 60usize];
    ["Offset of field: rte_eth_dev_info::max_vmdq_pools"]
        [::core::mem::offset_of!(rte_eth_dev_info, max_vmdq_pools) - 62usize];
    ["Offset of field: rte_eth_dev_info::rx_seg_capa"]
        [::core::mem::offset_of!(rte_eth_dev_info, rx_seg_capa) - 64usize];
    ["Offset of field: rte_eth_dev_info::rx_offload_capa"]
        [::core::mem::offset_of!(rte_eth_dev_info, rx_offload_capa) - 72usize];
    ["Offset of field: rte_eth_dev_info::tx_offload_capa"]
        [::core::mem::offset_of!(rte_eth_dev_info, tx_offload_capa) - 80usize];
    ["Offset of field: rte_eth_dev_info::rx_queue_offload_capa"]
        [::core::mem::offset_of!(rte_eth_dev_info, rx_queue_offload_capa) - 88usize];
    ["Offset of field: rte_eth_dev_info::tx_queue_offload_capa"]
        [::core::mem::offset_of!(rte_eth_dev_info, tx_queue_offload_capa) - 96usize];
    ["Offset of field: rte_eth_dev_info::reta_size"]
        [::core::mem::offset_of!(rte_eth_dev_info, reta_size) - 104usize];
    ["Offset of field: rte_eth_dev_info::hash_key_size"]
        [::core::mem::offset_of!(rte_eth_dev_info, hash_key_size) - 106usize];
    ["Offset of field: rte_eth_dev_info::rss_algo_capa"]
        [::core::mem::offset_of!(rte_eth_dev_info, rss_algo_capa) - 108usize];
    ["Offset of field: rte_eth_dev_info::flow_type_rss_offloads"]
        [::core::mem::offset_of!(rte_eth_dev_info, flow_type_rss_offloads) - 112usize];
    ["Offset of field: rte_eth_dev_info::default_rxconf"]
        [::core::mem::offset_of!(rte_eth_dev_info, default_rxconf) - 120usize];
    ["Offset of field: rte_eth_dev_info::default_txconf"]
        [::core::mem::offset_of!(rte_eth_dev_info, default_txconf) - 200usize];
    ["Offset of field: rte_eth_dev_info::vmdq_queue_base"]
        [::core::mem::offset_of!(rte_eth_dev_info, vmdq_queue_base) - 256usize];
    ["Offset of field: rte_eth_dev_info::vmdq_queue_num"]
        [::core::mem::offset_of!(rte_eth_dev_info, vmdq_queue_num) - 258usize];
    ["Offset of field: rte_eth_dev_info::vmdq_pool_base"]
        [::core::mem::offset_of!(rte_eth_dev_info, vmdq_pool_base) - 260usize];
    ["Offset of field: rte_eth_dev_info::rx_desc_lim"]
        [::core::mem::offset_of!(rte_eth_dev_info, rx_desc_lim) - 262usize];
    ["Offset of field: rte_eth_dev_info::tx_desc_lim"]
        [::core::mem::offset_of!(rte_eth_dev_info, tx_desc_lim) - 272usize];
    ["Offset of field: rte_eth_dev_info::speed_capa"]
        [::core::mem::offset_of!(rte_eth_dev_info, speed_capa) - 284usize];
    ["Offset of field: rte_eth_dev_info::nb_rx_queues"]
        [::core::mem::offset_of!(rte_eth_dev_info, nb_rx_queues) - 288usize];
    ["Offset of field: rte_eth_dev_info::nb_tx_queues"]
        [::core::mem::offset_of!(rte_eth_dev_info, nb_tx_queues) - 290usize];
    ["Offset of field: rte_eth_dev_info::max_rx_mempools"]
        [::core::mem::offset_of!(rte_eth_dev_info, max_rx_mempools) - 292usize];
    ["Offset of field: rte_eth_dev_info::default_rxportconf"]
        [::core::mem::offset_of!(rte_eth_dev_info, default_rxportconf) - 294usize];
    ["Offset of field: rte_eth_dev_info::default_txportconf"]
        [::core::mem::offset_of!(rte_eth_dev_info, default_txportconf) - 300usize];
    ["Offset of field: rte_eth_dev_info::dev_capa"]
        [::core::mem::offset_of!(rte_eth_dev_info, dev_capa) - 312usize];
    ["Offset of field: rte_eth_dev_info::switch_info"]
        [::core::mem::offset_of!(rte_eth_dev_info, switch_info) - 320usize];
    ["Offset of field: rte_eth_dev_info::err_handle_mode"]
        [::core::mem::offset_of!(rte_eth_dev_info, err_handle_mode) - 336usize];
    ["Offset of field: rte_eth_dev_info::reserved_64s"]
        [::core::mem::offset_of!(rte_eth_dev_info, reserved_64s) - 344usize];
    ["Offset of field: rte_eth_dev_info::reserved_ptrs"]
        [::core::mem::offset_of!(rte_eth_dev_info, reserved_ptrs) - 360usize];
};
unsafe extern "C" {
    pub fn rte_eth_dev_count_avail() -> u16;
}
unsafe extern "C" {
    pub fn rte_eth_dev_configure(
        port_id: u16,
        nb_rx_queue: u16,
        nb_tx_queue: u16,
        eth_conf: *const rte_eth_conf,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn rte_eth_rx_queue_setup(
        port_id: u16,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        socket_id: ::core::ffi::c_uint,
        rx_conf: *const rte_eth_rxconf,
        mb_pool: *mut rte_mempool,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn rte_eth_tx_queue_setup(
        port_id: u16,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        socket_id: ::core::ffi::c_uint,
        tx_conf: *const rte_eth_txconf,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn rte_eth_dev_socket_id(port_id: u16) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn rte_eth_dev_start(port_id: u16) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn rte_eth_dev_stop(port_id: u16) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn rte_eth_dev_close(port_id: u16) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn rte_eth_promiscuous_enable(port_id: u16) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn rte_eth_macaddr_get(port_id: u16, mac_addr: *mut rte_ether_addr) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn rte_eth_dev_info_get(
        port_id: u16,
        dev_info: *mut rte_eth_dev_info,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn dpdk_wrap_rte_eth_rx_burst(
        port_id: u16,
        queue_id: u16,
        rx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16;
}
unsafe extern "C" {
    pub fn dpdk_wrap_rte_eth_tx_burst(
        port_id: u16,
        queue_id: u16,
        tx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16;
}
unsafe extern "C" {
    pub fn dpdk_wrap_rte_pktmbuf_alloc(mp: *mut rte_mempool) -> *mut rte_mbuf;
}
unsafe extern "C" {
    pub fn dpdk_wrap_rte_pktmbuf_free(m: *mut rte_mbuf);
}
unsafe extern "C" {
    pub fn dpdk_wrap_rte_pktmbuf_mtod(m: *mut rte_mbuf) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn dpdk_wrap_rte_pktmbuf_data_len(m: *const rte_mbuf) -> u16;
}
unsafe extern "C" {
    pub fn dpdk_wrap_rte_pktmbuf_pkt_len(m: *const rte_mbuf) -> u32;
}
unsafe extern "C" {
    pub fn dpdk_wrap_rte_pktmbuf_append(m: *mut rte_mbuf, len: u16) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn dpdk_wrap_rte_pktmbuf_headroom(m: *const rte_mbuf) -> u16;
}
unsafe extern "C" {
    pub fn dpdk_wrap_rte_pktmbuf_tailroom(m: *const rte_mbuf) -> u16;
}
unsafe extern "C" {
    pub fn dpdk_wrap_rte_flow_create_queue_rule(
        port_id: u16,
        priority: u32,
        is_ipv4: ::core::ffi::c_int,
        dst_ip: *const u8,
        dst_mask: *const u8,
        queue_id: u16,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow;
}
unsafe extern "C" {
    pub fn dpdk_wrap_rte_flow_destroy(
        port_id: u16,
        flow: *mut rte_flow,
        error: *mut rte_flow_error,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn dpdk_wrap_rte_flow_flush(port_id: u16, error: *mut rte_flow_error)
        -> ::core::ffi::c_int;
}
