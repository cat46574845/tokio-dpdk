//! Device resolver module for DPDK runtime.
//!
//! This module provides OS-specific implementations for resolving
//! network device configuration from the system.

use std::io;

use smoltcp::wire::{IpCidr, Ipv4Address, Ipv6Address};

/// Resolved device configuration from the system.
#[derive(Debug, Clone)]
pub(crate) struct ResolvedDevice {
    /// Device name (e.g., "eth0", "ens5")
    pub name: String,

    /// MAC address
    pub mac: [u8; 6],

    /// IP addresses (IPv4 and IPv6)
    pub addresses: Vec<IpCidr>,

    /// IPv4 default gateway
    pub gateway_v4: Option<Ipv4Address>,

    /// IPv6 default gateway
    pub gateway_v6: Option<Ipv6Address>,

    /// CPU core to bind this device's worker to
    /// (derived from IRQ affinity)
    pub core: usize,
}

/// Resolve a device by name.
pub(crate) fn resolve_device(name: &str) -> io::Result<ResolvedDevice> {
    resolve_device_from_os(name)
}

// OS-specific implementations (deprecated - now using env_config.rs)

#[cfg(target_os = "windows")]
mod windows;

#[cfg(target_os = "linux")]
fn resolve_device_from_os(name: &str) -> io::Result<ResolvedDevice> {
    // Load from env.json (generated by scripts/dpdk/setup.sh)
    let env_config = super::env_config::DpdkEnvConfig::load().map_err(|e| {
        io::Error::new(
            io::ErrorKind::NotFound,
            format!(
                "Failed to load DPDK env config: {}. Run 'scripts/dpdk/setup.sh refresh-config' first.",
                e
            ),
        )
    })?;

    // Try to find device by PCI address first (e.g., "0000:28:00.0")
    // Then fall back to original interface name (e.g., "enp40s0")
    let device_config = env_config
        .find_by_pci(name)
        .or_else(|| env_config.find_by_name(name))
        .ok_or_else(|| {
            io::Error::new(
                io::ErrorKind::NotFound,
                format!(
                    "Device '{}' not found in /etc/dpdk/env.json. Run 'scripts/dpdk/setup.sh refresh-config'.",
                    name
                ),
            )
        })?;

    // Get the device index to select corresponding core from dpdk_cores
    let device_index = env_config
        .devices
        .iter()
        .filter(|d| d.role == super::env_config::DeviceRole::Dpdk)
        .position(|d| d.pci_address == device_config.pci_address)
        .unwrap_or(0);

    // Select core from dpdk_cores (fallback to 0 if not enough cores)
    let core = env_config
        .dpdk_cores
        .get(device_index)
        .copied()
        .unwrap_or(0);

    Ok(ResolvedDevice {
        name: name.to_string(),
        mac: device_config.mac,
        addresses: device_config.addresses.clone(),
        gateway_v4: device_config.gateway_v4,
        gateway_v6: device_config.gateway_v6,
        core,
    })
}

#[cfg(target_os = "windows")]
fn resolve_device_from_os(name: &str) -> io::Result<ResolvedDevice> {
    windows::resolve_device(name)
}

#[cfg(not(any(target_os = "linux", target_os = "windows")))]
fn resolve_device_from_os(_name: &str) -> io::Result<ResolvedDevice> {
    Err(io::Error::new(
        io::ErrorKind::Unsupported,
        "DPDK is only supported on Linux and Windows",
    ))
}
